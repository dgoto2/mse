# oem.R - DESC
# mse/R/oem.R

# Copyright European Union, 2018
# Author: Ernesto Jardim (EC JRC) <ernesto.jardim@ec.europa.eu>
#         Iago Mosqueira (EC JRC) <iago.mosqueira@ec.europa.eu>
#
# Distributed under the terms of the European Union Public Licence (EUPL) V.1.1.

# sampling.oem {{{

sampling.oem <- function(stk, deviances, observations, vy0, ay, tracking,
  oe=c("both","index","catch")) {
	
  # TODO needs more work to remove the index OE, for now index OE is mandatory 

	dataYears <- vy0
	assessmentYear <- ac(ay)
	# dataYears is a position vector, not the years themselves

	# carry on stock information in the observations for "short-cut" approach
	stock.n(observations$stk)[,assessmentYear] <- stock.n(stk)[,assessmentYear]	
	harvest(observations$stk)[,assessmentYear] <- harvest(stk)[,assessmentYear]	
	
	# catch.n
	# note it's adding 1 individual to avoid sca from crashing
	if(any(oe %in% c("both","catch"))){
		catch.n(observations$stk)[,max(dataYears)] <- catch.n(stk)[,max(dataYears)]*deviances$stk$catch.n[,max(dataYears)] + 1
		catch(observations$stk)[,max(dataYears)] <- computeCatch(observations$stk[,max(dataYears)])
		stk0 <- observations$stk[,dataYears]
	}

	# indices
	if(any(oe %in% c("both","index"))){
		for (idx_count in 1:length(observations$idx)){
			index(observations$idx[[idx_count]])[,max(dataYears)] <- stock.n(stk)[,max(dataYears)]*deviances$idx[[idx_count]][,max(dataYears)]
		}
		idx0 <- lapply(observations$idx, function(x) x[,dataYears])
	}

	# return
	list(stk=stk0, idx=idx0, observations=observations, tracking=tracking)
} # }}}

# perfect.oem {{{

perfect.oem <- function(stk, deviances, observations, vy0, ay, tracking){
	dataYears <- vy0
	assessmentYear <- ac(ay)
	stk0 <- stk[,dataYears]
	idx0 <- FLIndices(a=FLIndex(index=stock.n(stk)[,dataYears]*0.01))
	range(idx0[[1]])[c("startf","endf")] <- c(0,0)
	list(stk=stk0, idx=idx0, deviances=deviances, observations=observations, tracking=tracking)
} # }}}

# cpue.oem {{{

cpue.oem <- function(stk, deviances, observations, vy0, ay, tracking){

	dataYears <- vy0
	say <- ac(ay)
 

  # GET historical cpue
  cpue <- window(observations$idx[[1]], end=ay)

  ctime <- sum(range(cpue)[c("startf", "endf")]) / 2

  # GENERATE new observation of abundance
  obs <- quantSums(stock.n(stk)[,say] *
    exp(-harvest(stk)[,say] * ctime - m(stk)[,say] * ctime) *
    stock.wt(stk)[,say] * sel.pattern(cpue)[,say])

  index(cpue)[,say] <- obs * index.q(cpue)[,say]

  idx <- FLIndices(setNames(list(cpue), names(observations$idx)))
  observations$idx[[1]][,say] <- idx[[1]][,say]
	
  list(stk=stk, idx=idx, deviances=deviances,
    observations=observations, tracking=tracking)
} # }}}
